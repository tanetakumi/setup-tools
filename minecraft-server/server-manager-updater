#!/bin/bash
# Server Manager Auto-Updater Script
# Checks for updates from GitHub Releases and installs them if available

set -e

# Configuration
REPO="tanetakumi/setup-tools"  # Fixed GitHub repository
BINARY_NAME="server-manager"
BINARY_PATH="/usr/local/bin/${BINARY_NAME}"
BACKUP_PATH="/usr/local/bin/${BINARY_NAME}.backup"
VERSION_FILE="/var/lib/${BINARY_NAME}/.version"
LOG_FILE="/var/log/${BINARY_NAME}-updater.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    local level=$1
    shift
    local message="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${timestamp} [${level}] ${message}" | tee -a "$LOG_FILE"
}

log_info() {
    log "INFO" "${GREEN}$*${NC}"
}

log_warn() {
    log "WARN" "${YELLOW}$*${NC}"
}

log_error() {
    log "ERROR" "${RED}$*${NC}"
}

# Check if running as root
check_root() {
    if [ "$EUID" -ne 0 ]; then
        log_error "This script must be run as root (use sudo)"
        exit 1
    fi
}

# Get current installed version
get_current_version() {
    if [ -f "$BINARY_PATH" ]; then
        local version=$("$BINARY_PATH" --version 2>/dev/null || echo "unknown")
        echo "$version"
    else
        echo "not_installed"
    fi
}

# Get latest version from GitHub
get_latest_version() {
    local api_url="https://api.github.com/repos/${REPO}/releases/latest"
    local latest=$(curl -s --connect-timeout 10 --max-time 30 "$api_url" | grep -Po '"tag_name": "\K.*?(?=")')

    if [ -z "$latest" ]; then
        log_warn "Failed to fetch latest version from GitHub (network issue?)"
        return 1
    fi

    echo "$latest"
}

# Compare semantic versions
# Returns: 0 if equal, 1 if v1 > v2, 2 if v1 < v2
compare_versions() {
    local v1=$1
    local v2=$2

    # Remove 'v' prefix if present
    v1=${v1#v}
    v2=${v2#v}

    if [ "$v1" = "$v2" ]; then
        return 0
    fi

    local IFS=.
    local i ver1=($v1) ver2=($v2)

    # Fill empty positions with zeros
    for ((i=${#ver1[@]}; i<${#ver2[@]}; i++)); do
        ver1[i]=0
    done

    for ((i=0; i<${#ver1[@]}; i++)); do
        if [ -z "${ver2[i]}" ]; then
            ver2[i]=0
        fi

        if ((10#${ver1[i]} > 10#${ver2[i]})); then
            return 1
        fi

        if ((10#${ver1[i]} < 10#${ver2[i]})); then
            return 2
        fi
    done

    return 0
}

# Download and install new version
install_update() {
    local version=$1
    local download_url="https://github.com/${REPO}/releases/download/${version}/${BINARY_NAME}"
    local temp_file=$(mktemp)

    log_info "Downloading ${BINARY_NAME} ${version}..."

    if ! curl -sL --connect-timeout 10 --max-time 300 "$download_url" -o "$temp_file"; then
        log_error "Failed to download ${version} (network issue?)"
        rm -f "$temp_file"
        return 1
    fi

    # Verify it's a valid binary
    if ! file "$temp_file" | grep -q "executable"; then
        log_error "Downloaded file is not a valid executable"
        rm -f "$temp_file"
        return 1
    fi

    # Backup current binary
    if [ -f "$BINARY_PATH" ]; then
        log_info "Backing up current binary..."
        cp "$BINARY_PATH" "$BACKUP_PATH"
    fi

    # Install new binary
    log_info "Installing new binary..."
    chmod +x "$temp_file"
    mv "$temp_file" "$BINARY_PATH"

    # Save version info
    mkdir -p "$(dirname "$VERSION_FILE")"
    echo "$version" > "$VERSION_FILE"

    log_info "Successfully updated to ${version}"
    return 0
}

# Rollback to backup version
rollback() {
    if [ ! -f "$BACKUP_PATH" ]; then
        log_error "No backup found, cannot rollback"
        return 1
    fi

    log_warn "Rolling back to backup version..."
    cp "$BACKUP_PATH" "$BINARY_PATH"
    log_info "Rollback complete"
}

# Main update check and install
main() {
    check_root

    log_info "==================================="
    log_info "Server Manager Update Check"
    log_info "==================================="

    # Get current version
    local current_version=$(get_current_version)
    log_info "Current version: ${current_version}"

    # Get latest version
    local latest_version=$(get_latest_version)
    if [ $? -ne 0 ]; then
        log_warn "Failed to check for updates (network issue?). Continuing with current version..."
        exit 0  # Exit successfully to allow service to start
    fi
    log_info "Latest version: ${latest_version}"

    # Compare versions
    compare_versions "$current_version" "$latest_version"
    local result=$?

    if [ $result -eq 0 ]; then
        log_info "Already running the latest version"
        exit 0
    elif [ $result -eq 1 ]; then
        log_warn "Current version is newer than latest release (development version?)"
        exit 0
    elif [ $result -eq 2 ]; then
        log_info "Update available: ${current_version} -> ${latest_version}"

        # Install update
        if install_update "$latest_version"; then
            # Verify installation
            local new_version=$(get_current_version)
            if [ "$new_version" = "${latest_version#v}" ]; then
                log_info "${BLUE}Update completed successfully!${NC}"
                exit 0
            else
                log_error "Version mismatch after update. Rolling back..."
                rollback
                log_warn "Rollback completed. Continuing with previous version..."
                exit 0  # Exit successfully to allow service to start
            fi
        else
            log_warn "Update failed. Continuing with current version..."
            if [ -f "$BACKUP_PATH" ]; then
                rollback
            fi
            exit 0  # Exit successfully to allow service to start with current/backup version
        fi
    fi
}

# Handle script arguments
case "${1:-}" in
    --check-only)
        current=$(get_current_version)
        latest=$(get_latest_version)
        echo "Current: $current"
        echo "Latest: $latest"
        compare_versions "$current" "$latest"
        [ $? -eq 2 ] && echo "Update available" || echo "Up to date"
        ;;
    --rollback)
        check_root
        rollback
        ;;
    --force)
        check_root
        latest=$(get_latest_version)
        install_update "$latest"
        ;;
    *)
        main
        ;;
esac
